{"version":3,"sources":["../../src/Flowchart/util.ts","../../src/Flowchart/Node/OperationNode.tsx","../../src/Flowchart/Node/StartEndNode.tsx","../../src/Flowchart/Node/Node.tsx","../../src/Flowchart/Connection/constant.ts","../../src/Flowchart/Connection/Connection.tsx","../../src/Flowchart/Flowchart.tsx","App.tsx","index.tsx"],"names":["pathing","points","start","p1","end","p2","centerX","centerY","addVerticalCenterLine","third","second","forth","penult","addHorizontalCenterLine","addHorizontalTopLine","addHorizontalBottomLine","addVerticalRightLine","addVerticalLeftLine","addSecondXPenultY","addPenultXSecondY","startPosition","endPosition","direction","calcDirection","approximatelyEquals","distanceOfPoint2Point","Math","distanceOfPointToLine","point","line","k","b","n","m","getEdgeOfPoints","minX","maxX","x","y","isIntersected","p","rect","locateConnector","top","node","left","bottom","right","locateAngle","lineGenerator","d3","d","data","isSelected","borderColor","text","React","height","fill","strokeWidth","width","stroke","textAnchor","cx","cy","rx","ry","Circle","styled","props","G","isConnecting","onDoubleClick","onMouseDown","onConnectorMouseDown","position","useMemo","Object","key","r","event","defaultConnectionColors","pass","reject","selectedConnectionColors","nodes","getNodeConnectorOffset","useCallback","item","colors","i","source","destination","isLast","color","id","markerEnd","undefined","markerUnits","viewBox","refX","refY","markerWidth","markerHeight","orient","SVG","forwardRef","defaultNodes","defaultConnections","readonly","onEditNode","onCreateNode","onEditConnection","onCreateConnection","style","useState","internalNodes","setInternalNodes","internalConnections","setInternalConnections","useEffect","currentNodes","setCurrentNodes","currentConnections","setCurrentConnections","selectionInfo","setSelectionInfo","connectingInfo","setConnectingInfo","draggingInfo","setDraggingInfo","cursorToChartOffset","setCursorToChartOffset","handleSVGDoubleClick","Date","nodeData","name","type","handleSVGMouseDown","offsetY","handleSVGMouseMove","currentCursorToChartOffset","edge","tempCurrentNodes","calcIntersectedNodes","result","internalConnection","srcNodeData","destNodeData","calcIntersectedConnections","t","findIndex","delta","update","$set","moveCurrentNodes","indexes","internalNode","tempState","index","$apply","prev","remove","list1","prevState","interConn","currentConn","list2","$splice","a","interNode","handleSVGKeyDown","document","handleSVGMouseUp","locations","newConnection","sourcePosition","guidelines","sourceAnglePoints","sourceAnglePoint","lines","directions","destinationPoint","useImperativeHandle","ref","getData","connections","tabIndex","onKeyDown","onMouseUp","onMouseMove","currentNode","target","find","conn","fillOpacity","strokeDasharray","x1","guideline","y1","x2","y2","App","approvers","useRef","flowchartRef","visible","connectionForm","setConnectionForm","nodeForm","setNodeForm","className","disabled","onClick","alert","JSON","stringify","current","setConnections","setNodes","title","onCancel","onOk","labelAlign","labelCol","span","Item","label","value","onChange","Option","length","_event","option","children","ReactDOM","render","getElementById"],"mappings":"44CASA,SAASA,EAAQ,EAAjB,OAME,IAKA,EAiDA,EAtDMC,EAAN,GACMC,EAA0B,CAACC,EAAD,EAAOA,EAAvC,GACMC,EAAwB,CAACC,EAAD,EAAOA,EAArC,GACMC,EAAUJ,MAAYE,KAASF,EAAV,IAA3B,EACMK,EAAUL,MAAYE,KAASF,EAAV,IAA3B,EAEMM,EAAwB,WAC5B,IAAMC,EAA0B,CAACH,EAASI,EAA1C,IACMC,EAA0B,CAACL,EAASM,EAA1C,IACAX,UACAA,WAEIY,EAA0B,WAC9B,IAAMJ,EAA0B,CAACC,EAAD,GAAhC,GACMC,EAA0B,CAACC,EAAD,GAAhC,GACAX,UACAA,WAEIa,EAAuB,WAC3Bb,OAAY,CAACS,EAAD,GAAYR,KAAxBD,KACAA,OAAY,CAACW,EAAD,GAAYV,KAAxBD,MAEIc,EAA0B,WAC9Bd,OAAY,CAACS,EAAD,GAAYR,KAAxBD,KACAA,OAAY,CAACW,EAAD,GAAYV,KAAxBD,MAEIe,EAAuB,WAC3Bf,OAAY,CAACC,KAAD,GAAgBQ,EAA5BT,KACAA,OAAY,CAACC,KAAD,GAAgBU,EAA5BX,MAEIgB,EAAsB,WAC1BhB,OAAY,CAACC,KAAD,GAAgBQ,EAA5BT,KACAA,OAAY,CAACC,KAAD,GAAgBU,EAA5BX,MAEIiB,EAAoB,WACxBjB,OAAY,CAACS,EAAD,GAAYE,EAAxBX,MAEIkB,EAAoB,WACxBlB,OAAY,CAACW,EAAD,GAAYF,EAAxBT,MAEF,UACE,WACES,EAAS,CAACR,KAAD,GAAgBA,EAAzBQ,IACA,MACF,UACEA,EAAS,CAACR,EAAD,GAAWA,KAApBQ,IACA,MACF,aACEA,EAAS,CAACR,EAAD,GAAWA,KAApBQ,IACA,MACF,QACEA,EAAS,CAACR,KAAD,GAAgBA,EAAzBQ,IAIJ,UACE,YACEE,EAAS,CAACR,KAAD,GAAcA,EAAvBQ,IACA,MACF,UACEA,EAAS,CAACR,EAAD,GAASA,KAAlBQ,IACA,MACF,aACEA,EAAS,CAACR,EAAD,GAASA,KAAlBQ,IACA,MACF,QACEA,EAAS,CAACR,KAAD,GAAcA,EAAvBQ,IAGJX,UACAA,UACAmB,EAAgBA,GAAhBA,QACAC,EAAcA,GAAdA,OACA,IAAMC,EAAYC,EAAcpB,EAAhC,GAyCA,OAxCImB,gBAAJ,IACMF,aAAJ,SAAiCC,IAC3BX,KAAJ,IACEA,QAEEE,KAAJ,IACEA,UAIFU,gBAAJ,IACMF,cAAJ,QAAkCC,IAC5BX,KAAJ,IACEA,QAEEE,KAAJ,IACEA,UAIFU,gBAAJ,IACMF,YAAJ,UAAgCC,IAC1BX,KAAJ,IACEA,QAEEE,KAAJ,IACEA,UAIFU,gBAAJ,IACMF,WAAJ,WAA+BC,IACzBX,KAAJ,IACEA,QAEEE,KAAJ,IACEA,UAIN,GACE,SACE,aAAIQ,EACF,UACE,UACA,YACEF,IACA,MACF,QACEL,SAIC,cAAIO,EACT,UACE,UACEZ,IACA,MACF,QACEW,SAIC,WAAIC,EACT,UACE,UACA,YACEF,IACA,MACF,QACEL,SAMJ,UACE,UACA,YACEL,IACA,MACF,QACEW,IAKN,MAEF,QACE,aAAIC,EACF,UACE,YACE,MAEF,UACEF,IACA,MAEF,QACEL,SAIC,cAAIO,EACT,UACE,WACA,YACED,IACA,MACF,QACEH,SAIC,WAAII,EACT,UACE,WACED,IACA,MAEF,YACEN,IACA,MAEF,UACEG,SAQJ,UACE,WACA,YACE,MACF,QACEf,OAAY,CAACS,EAAD,GAAYE,EAAxBX,KAKN,MACF,SACE,aAAImB,EACF,UACE,WACEZ,IACA,MAEF,UACEU,IACA,MAEF,QACEC,SAIC,cAAIC,EACT,UACE,UACEZ,IACA,MAEF,QACEW,SAIC,WAAIC,EACT,UACE,YACEZ,IACA,MAEF,QACEU,SAMJ,UACE,WACA,UACEA,IACA,MACF,QACEL,IAKN,MACF,QACE,aAAIO,EACF,UACE,WACA,YACA,UACEN,IACA,MACF,QACEC,SAIC,cAAIK,EACT,UACE,WACEL,IACA,MAEF,YACEG,IACA,MAEF,UACEV,SAOC,WAAIY,EACT,UACE,WACEN,IACA,MAEF,YACEI,IACA,MAEF,UACE,MAEF,QACEV,SAMJ,UACE,WACEM,IACA,MAEF,YACE,MAEF,QACEI,IAKN,MACF,QACE,aAAIE,EACF,UACE,WACE,MAEF,YACEN,IACA,MAEF,QACEI,SAIC,cAAIE,EACT,UACE,WACEF,IACA,MAEF,YACEH,IACA,MAEF,UACEP,SAOC,WAAIY,EACT,UACE,WACED,IACA,MAEF,YACEL,IACA,MAEF,UACE,MAEF,QACEN,SAMJ,UACE,WACA,YACA,UACEM,IACA,MACF,QACEC,IAKN,MACF,SACE,aAAIK,EACF,UACE,WACEP,IACA,MAEF,QACEK,SAIC,cAAIE,EACT,UACE,WACED,IACA,MAEF,UACEN,IACA,MAEF,QACEK,SAIC,WAAIE,EACT,UACE,WACA,YACA,UACED,IACA,MACF,QACEX,SAMJ,UACE,WACA,UACEW,IACA,MACF,YACEX,IACA,MAEF,QACEU,IAKN,MACF,QACE,aAAIE,EACF,UACE,WACEP,IACA,MAEF,YACEM,IACA,MAEF,UACED,IACA,MAEF,QACEF,SAIC,cAAII,EACT,UACE,WACA,YACED,IACA,MACF,UACE,MAEF,QACEH,SAIC,WAAII,EACT,UACE,WACEH,IACA,MAEF,QACED,SAMJ,UACE,WACE,MAEF,YACEH,IACA,MAEF,UACEK,IACA,MAEF,QACED,IAKN,MACF,SACMG,aAAJ,SAAiCC,EAC/Bb,IACSY,aAAJ,WAAiCC,EACtCH,IAECE,aAAD,QAA8BC,GAC7BD,aAFI,UAEyBC,EAE9BF,IACSC,cAAJ,SAAkCC,EACvCH,IACSE,cAAJ,UAAkCC,EACvCF,IACSC,cAAJ,QAAkCC,EACvCR,IACSO,cAAJ,WAAkCC,EACvCH,IACSE,WAAJ,SAA+BC,GAE3BD,WAAJ,UAA+BC,GAE3BD,WAAJ,QAA+BC,EAHpCF,IAKSC,WAAJ,WAA+BC,EACpCb,IACSY,YAAJ,SAAgCC,EACrCH,IACSE,YAAJ,UAAgCC,GAE5BD,YAAJ,QAAgCC,EADrCR,IAGSO,YAAJ,WAAgCC,GACrCH,IAON,OAFAjB,UACAA,UACA,EAGF,SAASsB,EAAc,EAAvB,GAKE,OAAIlB,IAAOF,EAAPE,GAAemB,EAAoBnB,EAAD,EAAOF,EAA7C,GACE,IAEEE,IAAOF,EAAPE,GAAemB,EAAoBnB,EAAD,EAAOF,EAA7C,GACE,IAEEqB,EAAoBnB,EAAD,EAAOF,EAA1BqB,IAAmCnB,IAAOF,EAA9C,EACE,IAEEqB,EAAoBnB,EAAD,EAAOF,EAA1BqB,IAAmCnB,IAAOF,EAA9C,EACE,IAEEE,IAAOF,EAAPE,GAAeA,IAAOF,EAA1B,EACE,KAEEE,IAAOF,EAAPE,GAAeA,IAAOF,EAA1B,EACE,KAEEE,IAAOF,EAAPE,GAAeA,IAAOF,EAA1B,EACE,KAEF,KAGF,SAASsB,EAAsBtB,EAA/B,GACE,OAAOuB,WAAWvB,IAAOE,EAAlBqB,EAAwBvB,IAAOE,EAAtC,GAGF,SAASsB,EAAsBC,EAA/B,GACE,IAAM1B,EAAQ2B,EAAd,GACEzB,EAAMyB,EADR,GAEMC,GAAK1B,IAAQF,EAARE,GAAD,IAA0BA,IAAQF,EAARE,GAApC,GACM2B,EAAI7B,IAAU4B,EAAI5B,EAAxB,EACA,OAAOwB,SAASI,EAAIF,EAAJE,EAAcF,EAAdE,EAATJ,GAAsCA,UAAUI,IAAvD,GAOF,SAASN,EAAoBQ,EAA7B,GACE,OAAON,SAASO,EAATP,IAAP,EAGF,SAASQ,EAAgBjC,GACvB,IAAMkC,EAAOlC,EAAA,QAAc,cACzB,OAAO2B,MAAiBA,EAAjBA,EAAP,IADF,KAGMQ,EAAOnC,EAAA,QAAc,cACzB,OAAO2B,MAAiBA,EAAjBA,EAAP,IADF,GASA,MAAO,CAAE1B,MAAO,CAAEmC,EAAF,EAAWC,EANdrC,EAAA,QAAc,cACzB,OAAO2B,MAAiBA,EAAjBA,EAAP,IADF,MAMsCxB,IAAK,CAAEiC,EAAF,EAAWC,EAHzCrC,EAAA,QAAc,cACzB,OAAO2B,MAAiBA,EAAjBA,EAAP,IADF,KAMF,SAASW,EAAc,EAAvB,GAOE,OACEC,IAAMC,QAAND,GACAA,IAAMC,MADND,GAEAA,IAAMC,QAFND,GAGAA,IAAMC,MAJR,EAWF,SAASC,EAAgB,GAGvB,IAEMC,EAAM,CAAEN,EAAGO,IAFjB,GAEqCN,EAAGM,EAAKN,GACvCO,EAAO,CAAER,EAAGO,EAAL,EAAaN,EAAGM,IAF7B,IAGME,EAAS,CAAET,EAAGO,IAJpB,GAIwCN,EAAGM,IAAS,IAEpD,MAAO,CAAEC,KAAF,EAAQE,MADD,CAAEV,EAAGO,IAAL,IAAmBN,EAAGM,IAJpC,IAKsBD,IAAf,EAAoBG,UAO7B,SAASE,EAAYJ,GACnB,MAAO,CACL,CAAEP,EAAGO,EAAL,EAAaN,EAAGM,EAAKN,GACrB,CAAED,EAAGO,IAAL,IAAmBN,EAAGM,EAAKN,GAC3B,CAAED,EAAGO,IAAL,IAAmBN,EAAGM,IAAS,IAC/B,CAAEP,EAAGO,EAAL,EAAaN,EAAGM,IAAS,KAI7B,IAAMK,EAAqB,OAAAC,EAAA,QAEtB,mBAAOC,EAAP,MAFsB,GAGtB,mBAAOA,EAAP,M,kBCprBsBC,S,IAAMC,WACzBC,OADyBD,IAAaA,GAAA,EACX,UAAjC,UACME,EACHH,EAAD,eAAmBA,mBAEfA,qBACGA,oBADHA,MAEAA,eALN,KACE,cAKF,OACE,kBAACI,IAAD,cACE,0BACEnB,EAAGe,EAAKf,EACRC,EAAGc,EAAKd,EACRmB,OAAQ,GACRC,KAAM,UACNC,YAAa,EACbC,MAAO,IACPC,OAAQP,IAEV,0BAAMjB,EAAGe,IAAS,EAAGd,EAAGc,IAAS,IAC9BA,EAXL,MAaE,0BACEQ,MAAO,IACPH,OAAQ,GACRC,KAAM,QACNrB,EAAGe,EAAKf,EACRC,EAAGc,IAAS,GACZO,YAAa,EACbE,OAAQP,IAEV,0BAAMjB,EAAGe,IAAS,GAAId,EAAGc,OAAc,GAAIU,WAAY,UAvB3D,I,kBCRyBV,S,IAAMC,WACzBC,OADyBD,IAAaA,GAAA,EACX,UAAjC,UACME,EAAOH,yBAAb,MACA,OACE,kBAACI,IAAD,cACE,6BACEO,GAAIX,IAAS,GACbY,GAAIZ,IAAS,GACba,GAAI,GACJC,GAAI,GACJR,KAAM,QACNC,YAAa,EACbE,OAAQP,IAEV,0BAAMjB,EAAGe,IAAS,GAAId,EAAGc,MAAa,GAAIU,WAAY,UAX1D,I,wTCCF,IAAMK,EAASC,YAAH,SAAGA,CAAH,KAGC,mBAAYC,iBAAZ,KAQPC,EAAIF,YAAH,IAAGA,CAAH,KAiBP,c,IACEhB,SACAC,eACAkB,iBACAC,kBACAC,gBACAC,yBAEMC,EAAWC,mBAAQ,kBAAMlC,EAAN,KAA6B,CAAtD,IACA,OACE,kBAACc,IAAD,cACE,qBAAGgB,cAAeA,EAAeC,YAAaA,GAC3C,UAAArB,EAAA,cAAyBA,OACxB,qBAAeA,KAAMA,EAAMC,WAAYA,IAEvC,qBAAcD,KAAMA,EAAMC,WAAYA,IAEvCwB,OAAA,aAA0B,YACzB,OACE,qBACEC,IAAKA,EACLP,aAAcA,EACdR,GAAIY,KAAmCtC,EACvC2B,GAAIW,KAAmCrC,EACvCyC,EAAG,EACHN,YAAa,YACXO,oBACAN,aC9DhB,IAAMO,EAA0B,CAC9BC,KAD8B,UAE9BC,OAAQ,OAGJC,EAA2B,CAC/BF,KAD+B,UAE/BC,OAAQ,W,kBCOR/B,SACAiC,UACAhC,eACAoB,gBACAD,kBAEMc,EAAyBC,uBAC7B,cAEE,OAAO7C,EADM2C,EAAA,QAAa,mBAAUG,OAAV,KAA1B,IACA,KAEF,CALF,IAOMvF,EAASD,EACbsF,EAAuBlC,SAAD,GAAiBA,SADnB,UAEpBkC,EAAuBlC,cAAD,GAAsBA,cAFxB,UAGpBA,SAHoB,SAIpBA,cAJF,UAMMqC,EAASb,mBAAQ,WACrB,OAAOvB,EAAa+B,EAApB,IACC,CAFH,IAGA,OACE,2BACGnF,EAAA,KAAW,cACV,GAAIyF,EAAIzF,SAAR,EACE,OAAOuD,kBAACA,IAADA,SAAP,MAGF,IAAMmC,EAAS1F,EAAf,GACM2F,EAAc3F,EAAOyF,EAA3B,GACMG,EAASH,IAAMzF,SAArB,EACM6F,EAAQL,EAAOrC,EAArB,MACM2C,EAAK,QAAQD,cAAnB,IACA,OACE,kBAACtC,IAAD,UAAgBsB,IAAKY,GACnB,0BACE7B,OAAQ4B,EAAOrC,EAAD,MACdO,YAAa,EACbD,KAAM,OACNP,EAAGF,EAAc,CAAC0C,EAAF,IAChBK,UAAWH,EAAS,QAAH,WAAmBI,IAErCJ,GACC,4BACEE,GAAIA,EACJG,YAAa,cACbC,QAAS,YACTC,KAAM,EACNC,KAAM,EACNC,YAAa,GACbC,aAAc,GACdC,OAAQ,QAER,0BAAMrD,EAAG,6BAA8BO,KAAMoC,KAGjD,0BACErB,YAAaA,EACbD,cAAe,YACbQ,oBACAR,eAAa,IAAbA,SAEFX,OAAQ,cACRF,YAAa,EACbD,KAAM,OACNP,EAAGF,EAAc,CAAC0C,EAAF,W,gxBC7C9B,IAAMc,EAAMrC,YAAH,MAAGA,CAAH,K,EA8CMsC,sBACb,c,IAEIC,iBACAC,uB,IACAC,oBAAWA,GAAA,EACXC,eACAC,iBACAC,qBACAC,uBACAC,U,EAIwCC,mBAAQ,GAA3CC,OAAeC,O,EAGgCF,mBAAQ,GAAvDG,OAAqBC,OAG5BC,qBAAU,WACRD,KACAF,OACC,CAACT,EAHJY,I,MAIwCL,mBAAQ,IAAzCM,OAAcC,O,EAC+BP,mBAAQ,IAArDQ,OAAoBC,O,EAGeT,qBAAnCU,OAAeC,O,EACsBX,qBAArCY,OAAgBC,O,EAIiBb,qBAAjCc,OAAcC,O,EAQiCf,mBAAgB,CACpE9E,EADoE,EAEpEC,EAAG,IAFE6F,OAAqBC,OAItBC,EAAuB9C,uBAC3B,YACE,IAKA,EALM3D,EAAQ,CACZS,EAAG2C,cADS,QAEZ1C,EAAG0C,cAFS,QAGZe,IAAK,IAAIuC,MAsBX,OANEC,EAbGnB,EAAA,MAAmB,4BAAU5B,UAMtB4B,EAAA,MAAmB,0BAAU5B,UAO5B,EAAH,MAENgD,KAFM,MAGNC,KAAM,cATG,EAAH,CACNA,KADM,MAEND,KAAM,OAFRD,GANW,EAAH,CACNE,KADM,QAEND,KAAM,SAFRD,GAkBF,OAAOxB,QAAP,IAAOA,OAAP,EAAOA,EAAY,EAAnB,KAEF,CAACK,EA7BH,IA+BMsB,GAAqBnD,uBAAY,YAGrC,IAAIP,YAAiBA,EAAjBA,SAAJ,QAAsCA,iBAAtC,CAKA,IAAMpD,EAAQ,CACZS,EAAG2C,cADS,QAEZ1C,EAAG0C,cAAkB2D,SAEvBb,EAAiB,CACf5H,MADe,EAEfE,IAAKwB,IAEP8F,MACAE,SAjBF,IAmBMgB,GAAqBrD,uBACzB,YACE,IAAMsD,EAAoC,CACxCxG,EAAG2C,cADqC,QAExC1C,EAAG0C,cAAkB2D,SAKvB,GAFAP,KAEA,EAAmB,CACjBN,EAAiB,CACf5H,MAAO2H,EADQ,MAEfzH,IAAKyI,IAGP,IAAMC,EAAO5G,EAAgB,CAC3B2F,EAD2B,MAA7B,IAIAH,ENkhBV,SAA8B,EAA9B,GAIE,IAAMqB,EAAN,GAMA,OALA3B,WAAsB,YAChBpE,EAAA,SAAuB,mBAAWT,EAAcX,EAAzB,OACzBmH,aAGJ,EM3hBUC,CAAqB5B,EAArB,QAA8C,mBAAU5B,EAAV,OAEhDoC,ENmfV,SAAoC,EAApC,KAME,IADA,IACA,EADMqB,EAAN,G,iBACWC,UACHC,EAAc/B,EAAA,MAClB,mBAAU5B,OAAY0D,SAAtB,MAEIE,EAAehC,EAAA,MACnB,mBAAU5B,OAAY0D,cAAtB,MAEalJ,EACb0C,KAA8BwG,SADV,UAEpBxG,KAA+BwG,cAFX,UAGpBA,SAHoB,SAIpBA,cAJF,UAOE,MAAY,mBAAW3G,EAAc,CAAEF,EAAGT,EAAL,GAAeU,EAAGV,EAAM,IAAjD,OAEZqH,WAhBJ,sBAAsD,IAmBtD,SM3gBUI,CAA2BjC,EAAeE,EAD5CM,SAGSK,GACTZ,GAAiB,YAEf,IADA,IAAI4B,EAAJ,E,WACSvD,G,MACD4D,EAAIrB,SAAV,GACMsB,EAAYN,EAAA,WAAiB,mBAAUzD,OAAV,KAC7BgE,EAAQvB,QAAd,GACAgB,EAASQ,IAAOR,IAAD,SACA,CACX5G,EAAG,CACDqH,KAAMb,IAA+BW,EAAMnH,GAE7CC,EAAG,CACDoH,KAAMb,IAA+BW,EAAMlH,IANjD2G,KAJOvD,EAAT,EAAgBA,EAAIuC,SAApB,OAAgDvC,IAAK,EAA5CA,GAeT,cAIN,CAACuC,EAAcX,EAAqBF,EA/CtC,IAiDMuC,GAAmBpE,uBACvB,cACE,IAAMqE,EAAUnC,EAAA,KAAiB,mBAC/BL,EAAA,WACE,mBAAkByC,OAAlB,QAGJxC,GAAiB,YAEf,IADA,IACA,EADIyC,EAAJ,EACA,sBAA6B,OAAlBC,EAAkB,QAC3BD,EAAYL,IAAOK,IAAD,SACP,CACPzH,EAAG,CACD2H,OAAQ,mBAAUC,EAAV,IAEV3H,EAAG,CACD0H,OAAQ,mBAAUC,EAAV,KANdH,IAWF,cAGJ,CAACrC,EAxBH,IA0BMyC,GAAS3E,uBAAY,WACzB,IAGAgC,GAAuB,YAErB,IAAM4C,EAGAxC,EAAA,KAAuB,kBAAiB,CAC5CyC,EAAA,WAAoB,mBAAeC,OAAiBC,EAAhC,MADO,MAKvBC,EAA4B9C,EAAA,KAC3B,mBACHH,EAAA,QACE,mBACE+C,iBACAA,mBAFF,QAH4B,YAS3B,kBAAiB,CACpBD,EAAA,WAAoB,mBAAeC,OAAiBC,EAAhC,MADjB,MAIP,OAAOb,IAAOW,EAAW,CACvBI,QAAS,qBAA0B,qBAAUzI,KAAO0I,EAAjB,WAKvCpD,GAAiB,mBACfoC,IAAOW,EAAW,CAChBI,QAAS/C,EAAA,KACF,kBAAc,CACjB2C,EAAA,WAAoB,mBAAeM,OAAf,KADjB,MADE,MAKD,qBAAU3I,KAAO0I,EAAjB,cAGX,CAAC9C,EAAoBF,EAAcH,EA3CtC,IA4CMqD,GAAmBpF,uBACvB,YACE,OAAQP,EAAR,SACE,QACE2E,IAAgB,GAAhBA,GACA,MACF,QACEA,GAAiB,GAAjBA,IACA,MACF,QACEA,GAAiB,GAAjBA,GACA,MACF,QACEA,GAAiB,EAAjBA,IACA,MACF,QACEjC,MACAE,MACA,MACF,SAEK5C,WAAiBA,EAAlB,UACA4F,yBAA2BA,wBAF7B,WAIElD,MACAE,MACAF,EAAgBN,EAAA,KAAkB,mBAAU5B,EAAV,OAClCoC,EAAsB,GAAD,OAArBA,KAEF,MACF,QACA,OACEsC,QAMN,CAACvC,EAAoBP,EAAeuC,GAtCtC,KAwCMkB,GAAmBtF,uBAAY,WA4BnC,GA3BAuC,UACAE,UACAE,UAGA,GACEb,GAAiB,YAEf,IADA,IACA,EADI4B,EAAJ,E,mBACWK,UACTL,EAASQ,IAAOR,IAAD,MACZA,EAAA,WAAiB,mBAAUzD,OAAV,MAA2B,CAC3CnD,EAAG,CACD2H,OAAQ,sBACNtI,WAAWA,cAAXA,MAEJY,EAAG,CACD0H,OAAQ,sBACNtI,WAAWA,cAAXA,OARRuH,KADF,IAAgBhB,EAAhB,uBAAqC,IAcrC,YAKJ,GAKA,IAFA,IAEA,EAFIrF,EAAJ,KACI+B,EAAJ,KACA,sBAA0C,KAA/BkF,EAA+B,QAClCiB,EAAYpI,EAAlB,GACA,IAAK,IAAL,OAA8B,CAExBjB,EADUqJ,EAAd,GACIrJ,GAAJ,IACEmB,IACA+B,MAIN,GAAK/B,GAAL,GAGImF,cAA6BnF,EAAjC,IAIA,INiWoB,EAA1B,IMjWYmI,GNiWc,EMhWlBhD,SADoC,GNiW5C,EM/VQA,EAFoC,eNiW5C,EM9VQnF,EAHoC,GNuWnC,CACL+C,OAAQ,CAAEI,GAAF,EAAgBpB,SAAUqG,GAClCpF,YAAa,CAAEG,GAAF,EAAqBpB,SMzWhC,GN0WFoB,IAAK,IAHA,KAIL0C,KAAM,SMrWJxB,eAAkB,IAAlBA,KAAkB,EAAlBA,OACC,CAAC,EAAD,MAzDH,IAkEIhH,QAAJ,EACA,KAAoB,CAElB,IADA,IACA,GADIoB,GAAJ,KACA,yBAA0C,KAClCyJ,GAAYpI,EADsB,UAExC,IAAK,IAAL,SAA8B,CAExBjB,EADUqJ,GAAd,IACIrJ,GAAJ,IACEJ,QAKNpB,GAASD,EACP0C,EAAgBqF,EAAhBrF,QAAuCqF,EADzB,kBAGdA,EAHc,eAAhB9H,IAOF,IAAMgL,GAAN,GACA,KACE,IADgB,IAChB,GADgB,cAKd,IALc,IACLtF,EADK,SAERuF,EAAoBlI,EACxBoE,EAAA,MAAmB,mBAAU5B,OAAV,MAEZE,EAAT,EAAgBA,EAAIwF,EAApB,OAA8CxF,IAAK,CACjD,IAAMyF,EAAmB,CACvB9I,EADuB,GACpBX,WAAWA,WAAWwJ,KAAXxJ,GAAXA,IACHY,EAAyD,GAAtDZ,WAAWA,WAAWwJ,KAAXxJ,GAAXA,KAGD0J,OAAa,EACbC,OAAiE,EACrE,UACE,OACED,EAAQ,CACN,CAAC,CAAE/I,EAAG8I,EAAL,EAAyB7I,EAAG,GADvB,GAEN,CAAC,CAAED,EAAF,EAAQC,EAAG6I,EAAiB7I,GAF/B8I,IAIAC,EAAa,CAAC,KAAM,IAApBA,KACA,MAEF,OACED,EAAQ,CACN,CAAC,CAAE/I,EAAG8I,EAAL,EAAyB7I,EAAG,GADvB,GAGN,CAAC,CAAED,EAAF,IAAYC,EAAG6I,EAAiB7I,GAHnC8I,IAKAC,EAAa,CAAC,KAAM,IAApBA,KACA,MAEF,OACED,EAAQ,CACN,CAAC,CAAE/I,EAAG8I,EAAL,EAAyB7I,EAAG,KADvB,GAEN,CAAC,CAAED,EAAF,IAAYC,EAAG6I,EAAiB7I,GAFnC8I,IAIAC,EAAa,CAAC,IAAK,KAAnBA,KACA,MAEF,QACED,EAAQ,CACN,CAAC,CAAE/I,EAAG8I,EAAL,EAAyB7I,EAAG,KADvB,GAEN,CAAC,CAAED,EAAF,EAAQC,EAAG6I,EAAiB7I,GAF/B8I,IAIAC,EAAa,CAAC,IAAK,KAAnBA,KAKJ,cAA0BjE,EAAA,QACxB,mBAAkByC,OAAlB,QADF,aAEG,CAED,IAFC,IAED,EADIhI,EAAJ,KACA,IAA+BmB,EAF9B,YAED,aAAyD,KAA9CsI,EAA8C,QACjDhK,EAAYC,EAAc,EAAhC,GAKE8J,kBACC1J,EAAsB2J,EAAkBF,EAAxCzJ,OACCA,EAAsB2J,EAAkBF,EAAxCzJ,IAHJ,KAMIE,UACAJ,EAAsB6J,EAAtB7J,GACEA,EAAsBI,EAAD,GAAUA,EAHnC,OAKEA,EAAO,CAACyJ,EAARzJ,IAIN,GACEoJ,cAxER,KAAqBhD,EAArB,yBAA0C,KAwF5C,OATAsD,8BAAoBC,GAAK,iBAAO,CAC9BC,QAD8B,WAE5B,MAAO,CACLpG,MADK,EAELqG,YAAapE,QAMjB,kBAAC9D,IAAD,cACE,qBACEuC,GAAI,QACJ4F,SAAU,EACVC,UAAWjB,GACXzD,MAAOA,EACP1C,cAAe6D,EACfwD,UAAWhB,GACXpG,YAAaiE,GACboD,YAAalD,IARf,OAUGxB,QAVH,IAUGA,OAVH,EAUGA,EAAA,KAAmB,mBAClB,qBACEtC,IAAKlC,EAAKmD,GACV1C,WAAYoE,EAAA,MAAkB,mBAAUjC,IAAS5C,EAAnB,MAC9B2B,kBAAiC0B,IAAnB8B,EACd3E,KAAMR,EACN4B,cAAe,YACbQ,oBACA8B,eAAU,IAAVA,KAAU,EAAVA,IAEFrC,YAAa,YACX,GAAIO,WAAiBA,EAArB,QAAoC,CAClC,IAAMuE,EAAY9B,EAAA,WAChB,mBAAUjC,IAAS5C,EAAnB,MAGA8E,GADF,IAAI6B,EACc,GAAD,UAAmB3G,EAAlC8E,KAGE+B,IAAOhC,EAAc,CACnB+C,QAAS,CAAC,CAACjB,EAAF,WAIV,CACL,IAAIR,EAAJ,EAEGtB,EAAA,MAAkB,mBAAiBsE,IAAgBnJ,EAAjC,QAEnBmG,EAAmB,CAACnG,EAApBmG,IACArB,MAEFE,MACAM,EAAgB,CACd8D,OADc,EAEdxC,MAAOT,EAAA,KAAqB,YAC1B,IAAMkD,EAAO7E,EAAA,MACX,mBAAU5B,OAAV,KAEF,MAAO,CACLnD,EAAG8F,IAAwB8D,EADtB,EAEL3J,EAAG6F,IAAwB8D,EAAK3J,UAM1CoC,qBAAsB,YACpB,QAAI9B,QAIJoF,EAAkB,CAChBrC,OADgB,EAEhBqF,eAAgBrG,UAhE1B,OAqEG2C,QArEH,IAqEGA,OArEH,EAqEGA,EAAA,KAAyB,YACxB,OACE,qBACExC,IAAKoH,EAAKnG,GACV1C,WAAYsE,EAAA,MACV,mBAAUuE,OAAY1G,EAAtB,MAEFhB,cAAe,yBACbwC,QADa,IACbA,OADa,EACbA,EAAgB,EADH,IAGfvC,YAAa,YACX,GAAIO,WAAiBA,EAArB,QAAoC,CAClC,IAAMuE,EAAY5B,EAAA,WAChB,mBAAUnC,OAAY0G,EAAtB,MAGAtE,GADF,IAAI2B,EACoB,GAAD,UAArB3B,IAGE6B,IAAO9B,EAAoB,CACzB6C,QAAS,CAAC,CAACjB,EAAF,YAKf7B,MACAE,EAAsB,CAAtBA,KAGJxE,KAAM8I,EACN7G,MAAO+B,OAIZS,GACC,0BACEhE,OAAQ,YACRH,KAAM,YACNyI,YAAa,GACb9J,EACEH,EAAgB,CAAC2F,EAAD,MAAsBA,EAAtC3F,YACGG,EAELC,EACEJ,EAAgB,CAAC2F,EAAD,MAAsBA,EAAtC3F,YACGI,EAELsB,MACE1B,EAAgB,CAAC2F,EAAD,MAAsBA,EAAtC3F,YAEAA,EAAgB,CAAC2F,EAAD,MAAsBA,EAAtC3F,YACGG,EAELoB,OACEvB,EAAgB,CAAC2F,EAAD,MAAsBA,EAAtC3F,YAEAA,EAAgB,CAAC2F,EAAD,MAAsBA,EAAtC3F,YACGI,IAIRyF,GACC,2BACG9H,GAAA,KAAY,cACX,GAAIyF,EAAIzF,UAAR,EACE,OAAOuD,kBAACA,IAADA,SAAP,MAGF,IAAMmC,EAAS1F,GAAf,GACM2F,EAAc3F,GAAQyF,EAA5B,GACMG,EAASH,IAAMzF,UAArB,EACM6F,EAAQb,EAAd,KACMc,EAAK,QAAQD,cAAnB,IACA,OACE,kBAACtC,IAAD,cACE,0BACEK,OAAQoB,EAAwBC,KAChCvB,YAAa,EACbD,KAAM,OACNP,EAAGF,EAAc,CAAC0C,EAAF,IAChBK,UAAWH,EAAS,QAAH,WAAmBI,IAErCJ,GACC,4BACEE,GAAIA,EACJG,YAAa,cACbC,QAAS,YACTC,KAAM,EACNC,KAAM,EACNC,YAAa,GACbC,aAAc,GACdC,OAAQ,QAER,0BAAMrD,EAAG,6BAA8BO,KAAMoC,KAGjD,0BACEjC,OAAQ,cACRF,YAAa,EACbD,KAAM,OACNP,EAAGF,EAAc,CAAC0C,EAAF,WAO3BsF,GAAA,KAAe,qBACd,uBAAGnG,IAAKiF,GACN,0BACEqC,gBAAiB,MACjBvI,OAAQ,UACRF,YAAa,EACbD,KAAM,OACN2I,GAAIC,KAAajK,EACjBkK,GAAID,KAAahK,EACjBkK,GAAIF,KAAajK,EACjBoK,GAAIH,KAAahK,a,+DChalBoK,G,OAlRH,WAAO,IAAD,EACAvF,mBAAqB,CACnC,CACEsB,KAAM,QACND,KAAM,QACNnG,EAAG,IACHC,EAAG,IACHyD,GAAI,cACJ4G,UAAW,IAEb,CACElE,KAAM,MACND,KAAM,MACNnG,EAAG,IACHC,EAAG,IACHyD,GAAI,cACJ4G,UAAW,IAEb,CACEtK,EAAG,IACHC,EAAG,IACHyD,GAAI,cACJyC,KAAM,MACNC,KAAM,YACNkE,UAAW,CAAC,CAAEnE,KAAM,QAASzC,GAAI,OAEnC,CACE1D,EAAG,IACHC,EAAG,IACHyD,GAAI,cACJyC,KAAM,MACNC,KAAM,YACNkE,UAAW,MA/BRtH,EADS,sBAmCM8B,mBAA2B,CAC/C,CACExB,OAAQ,CAAEI,GAAI,cAAepB,SAAU,SACvCiB,YAAa,CAAEG,GAAI,cAAepB,SAAU,QAC5CoB,GAAI,cACJ0C,KAAM,QAER,CACE9C,OAAQ,CAAEI,GAAI,cAAepB,SAAU,SACvCiB,YAAa,CAAEG,GAAI,cAAepB,SAAU,QAC5CoB,GAAI,cACJ0C,KAAM,QAER,CACE9C,OAAQ,CAAEI,GAAI,cAAepB,SAAU,UACvCiB,YAAa,CAAEG,GAAI,cAAepB,SAAU,QAC5CoB,GAAI,cACJ0C,KAAM,QAER,CACE9C,OAAQ,CAAEI,GAAI,cAAepB,SAAU,SACvCiB,YAAa,CAAEG,GAAI,cAAepB,SAAU,UAC5CoB,GAAI,cACJ0C,KAAM,UAvBHiD,EAnCS,oBA6DVrE,EAAmBuF,mBACnBrF,EAAyBqF,mBACzBC,EAAeD,mBA/DL,EAgE4BzF,mBAIzC,CAAE2F,SAAS,EAAOrE,KAAM,SApEX,mBAgETsE,EAhES,KAgEOC,EAhEP,OAqEgB7F,mBAM7B,CACD2F,SAAS,EACTtE,KAAM,GACNC,KAAM,cA9EQ,mBAqETwE,EArES,KAqECC,EArED,KAiFhB,OAAO,yBAAKC,UAAU,YAAYjG,MAAO,CAAEzD,OAAQ,MACjD,wBAAI0J,UAAU,SAAd,mBACA,wBAAIA,UAAU,YAAd,0DAGA,yBAAKpH,GAAG,WACN,4BAAQqH,UAAU,EAAMC,QAAS,cAAjC,4BAIA,4BAAQD,UAAU,GAAlB,eACA,4BAAQA,UAAU,GAAlB,2BACA,4BACEC,QAAS,kBACPC,MAAMC,KAAKC,UAAUX,EAAaY,QAAQhC,cAF9C,SAQF,oCACE,kBAAC,EAAD,CACED,IAAKqB,EACL7F,iBAAkB,SAAC5D,EAAMsK,GACvBnG,EAAuBkG,QAAUC,EACjCV,EAAkB,CAChBF,SAAS,EACT/G,GAAI3C,EAAK2C,GACT0C,KAAMrF,EAAKqF,QAGfxB,mBAAoB,SAAC7D,EAAMsK,GACzBnG,EAAuBkG,QAAUC,EACjCA,GAAe,SAACtD,GAAD,4BAAmBA,GAAnB,CAA8BhH,QAE/C0D,WAAY,SAAC1D,EAAMuK,GACjBtG,EAAiBoG,QAAUE,EAC3BT,EAAY,CACVP,UAAWvJ,EAAKuJ,UAChBnE,KAAMpF,EAAKoF,KACXC,KAAMrF,EAAKqF,KACXqE,SAAS,EACT/G,GAAI3C,EAAK2C,MAGbgB,aAAc,SAAC3D,EAAMuK,GACnBtG,EAAiBoG,QAAUE,EAC3BA,GAAS,SAACvD,GAAD,4BACJA,GADI,aAAC,eAEHhH,GAFE,IAEIuJ,UAAW,WAG1BhG,aAActB,EACduB,mBAAoB8E,IAEtB,kBAAC,IAAD,CACEoB,QAASG,EAASH,QAClBc,MAAO,eACPhK,MAAO,IACPiK,SAAU,kBACRX,EAAY,CACVnH,QAAIE,EACJwC,KAAM,YACNqE,SAAS,EACTtE,KAAM,GACNmE,eAAW1G,KAGf6H,KAAM,WACJZ,EAAY,CACVnH,QAAIE,EACJwC,KAAM,YACNqE,SAAS,EACTtE,KAAM,GACNmE,eAAW1G,IAEboB,EAAiBoG,SAAS,SAACrD,GAAD,OACxBX,IAAOW,EAAD,eACHA,EAAUb,WAAU,SAAC/D,GAAD,OAAUA,EAAKO,KAAOkH,EAASlH,MAAM,CACxDyC,KAAM,CACJkB,KAAMuD,EAASzE,MAEjBC,KAAM,CACJiB,KAAMuD,EAASxE,MAEjBkE,UAAW,CACTjD,KAAMuD,EAASN,mBAOzB,kBAAC,IAAD,CACEoB,WAAY,QACZC,SAAU,CACRC,KAAM,IAGR,kBAAC,IAAKC,KAAN,CAAWC,MAAO,gBAChB,kBAAC,IAAD,CACEC,MAAOnB,EAASzE,KAChB6F,SAAU,SAACrJ,GAAD,OACRkI,GAAY,SAAC9C,GAAD,mBAAC,eACRA,GADO,IAEV5B,KAAMxD,EAAMgH,OAAOoC,eAK3B,kBAAC,IAAKF,KAAN,CAAWC,MAAO,gBAChB,kBAAC,IAAD,CACEC,MAAOnB,EAASxE,KAChB4F,SAAU,SAACrJ,GACTkI,GAAY,SAAC9C,GAAD,mBAAC,eACRA,GADO,IAEV3B,KAAMzD,SAIV,kBAAC,IAAOsJ,OAAR,CAAeF,MAAO,SAAtB,gBACA,kBAAC,IAAOE,OAAR,CAAeF,MAAO,OAAtB,gBACA,kBAAC,IAAOE,OAAR,CAAeF,MAAO,aAAtB,kBAGJ,kBAAC,IAAKF,KAAN,CAAWC,MAAO,sBAChB,kBAAC,IAAD,CACEC,MAAOnB,EAASN,WAAaM,EAASN,UAAU4B,OAAS,EAAItB,EAASN,UAAU,GAAGnE,UAAOvC,EAC1FoI,SAAU,SAACG,EAAQC,GACjBvB,GAAY,SAAC9C,GAAD,mBAAC,eACRA,GADO,IAEVuC,UAAW,CAAC,CAAEnE,KAAMiG,EAAOC,SAAU3I,GAAI0I,EAAOL,eAIpD,kBAAC,IAAOE,OAAR,CAAeF,MAAO,KAAtB,SACA,kBAAC,IAAOE,OAAR,CAAeF,MAAO,KAAtB,gBAKR,kBAAC,IAAD,CACEtB,QAASC,EAAeD,QACxBc,MAAO,eACPhK,MAAO,IACPiK,SAAU,kBACRb,EAAkB,CAChBjH,QAAIE,EACJwC,KAAM,OACNqE,SAAS,KAGbgB,KAAM,WACJd,EAAkB,CAChBjH,QAAIE,EACJwC,KAAM,OACNqE,SAAS,IAEXvF,EAAuBkG,SAAS,SAACrD,GAAD,OAC9BX,IAAOW,EAAD,eACHA,EAAUb,WACT,SAAC/D,GAAD,OAAUA,EAAKO,KAAOgH,EAAehH,MACnC,CACF0C,KAAM,CACJiB,KAAMqD,EAAetE,cAO/B,kBAAC,IAAD,KACE,kBAAC,IAAKyF,KAAN,CAAWC,MAAO,gBAChB,kBAAC,IAAD,CACEC,MAAOrB,EAAetE,KACtB4F,SAAU,SAACrJ,GACTgI,GAAkB,SAAC5C,GAAD,mBAAC,eACdA,GADa,IAEhB3B,KAAMzD,SAIV,kBAAC,IAAOsJ,OAAR,CAAeF,MAAO,QAAtB,gBACA,kBAAC,IAAOE,OAAR,CAAeF,MAAO,UAAtB,wBC3QdO,IAASC,OAAO,kBAAC,EAAD,MAAShE,SAASiE,eAAe,W","file":"static/js/main.b0a02e49.chunk.js","sourcesContent":["import {\n  ConnectionData,\n  ConnectorPosition,\n  Line,\n  NodeData,\n  Point,\n} from \"./schema\";\nimport * as d3 from \"d3\";\n\nfunction pathing(\n  p1: Point,\n  p2: Point,\n  startPosition: ConnectorPosition,\n  endPosition: ConnectorPosition | null\n): [number, number][] {\n  const points: [number, number][] = [];\n  const start: [number, number] = [p1.x, p1.y];\n  const end: [number, number] = [p2.x, p2.y];\n  const centerX = start[0] + (end[0] - start[0]) / 2;\n  const centerY = start[1] + (end[1] - start[1]) / 2;\n  let second: [number, number];\n  const addVerticalCenterLine = function () {\n    const third: [number, number] = [centerX, second[1]];\n    const forth: [number, number] = [centerX, penult[1]];\n    points.push(third);\n    points.push(forth);\n  };\n  const addHorizontalCenterLine = function () {\n    const third: [number, number] = [second[0], centerY];\n    const forth: [number, number] = [penult[0], centerY];\n    points.push(third);\n    points.push(forth);\n  };\n  const addHorizontalTopLine = function () {\n    points.push([second[0], start[1] - 50]);\n    points.push([penult[0], start[1] - 50]);\n  };\n  const addHorizontalBottomLine = function () {\n    points.push([second[0], start[1] + 50]);\n    points.push([penult[0], start[1] + 50]);\n  };\n  const addVerticalRightLine = function () {\n    points.push([start[0] + 80, second[1]]);\n    points.push([start[0] + 80, penult[1]]);\n  };\n  const addVerticalLeftLine = function () {\n    points.push([start[0] - 80, second[1]]);\n    points.push([start[0] - 80, penult[1]]);\n  };\n  const addSecondXPenultY = function () {\n    points.push([second[0], penult[1]]);\n  };\n  const addPenultXSecondY = function () {\n    points.push([penult[0], second[1]]);\n  };\n  switch (startPosition) {\n    case \"left\":\n      second = [start[0] - 20, start[1]];\n      break;\n    case \"top\":\n      second = [start[0], start[1] - 20];\n      break;\n    case \"bottom\":\n      second = [start[0], start[1] + 20];\n      break;\n    default:\n      second = [start[0] + 20, start[1]];\n      break;\n  }\n  let penult: [number, number];\n  switch (endPosition) {\n    case \"right\":\n      penult = [end[0] + 20, end[1]];\n      break;\n    case \"top\":\n      penult = [end[0], end[1] - 20];\n      break;\n    case \"bottom\":\n      penult = [end[0], end[1] + 20];\n      break;\n    default:\n      penult = [end[0] - 20, end[1]];\n      break;\n  }\n  points.push(start);\n  points.push(second);\n  startPosition = startPosition || \"right\";\n  endPosition = endPosition || \"left\";\n  const direction = calcDirection(p1, p2);\n  if (direction.indexOf(\"r\") > -1) {\n    if (startPosition === \"right\" || endPosition === \"left\") {\n      if (second[0] > centerX) {\n        second[0] = centerX;\n      }\n      if (penult[0] < centerX) {\n        penult[0] = centerX;\n      }\n    }\n  }\n  if (direction.indexOf(\"d\") > -1) {\n    if (startPosition === \"bottom\" || endPosition === \"top\") {\n      if (second[1] > centerY) {\n        second[1] = centerY;\n      }\n      if (penult[1] < centerY) {\n        penult[1] = centerY;\n      }\n    }\n  }\n  if (direction.indexOf(\"l\") > -1) {\n    if (startPosition === \"left\" || endPosition === \"right\") {\n      if (second[0] < centerX) {\n        second[0] = centerX;\n      }\n      if (penult[0] > centerX) {\n        penult[0] = centerX;\n      }\n    }\n  }\n  if (direction.indexOf(\"u\") > -1) {\n    if (startPosition === \"top\" || endPosition === \"bottom\") {\n      if (second[1] < centerY) {\n        second[1] = centerY;\n      }\n      if (penult[1] > centerY) {\n        penult[1] = centerY;\n      }\n    }\n  }\n  switch (direction) {\n    case \"lu\": {\n      if (startPosition === \"right\") {\n        switch (endPosition) {\n          case \"top\":\n          case \"right\":\n            addSecondXPenultY();\n            break;\n          default: {\n            addHorizontalCenterLine();\n            break;\n          }\n        }\n      } else if (startPosition === \"bottom\") {\n        switch (endPosition) {\n          case \"top\":\n            addVerticalCenterLine();\n            break;\n          default: {\n            addPenultXSecondY();\n            break;\n          }\n        }\n      } else if (startPosition === \"top\") {\n        switch (endPosition) {\n          case \"top\":\n          case \"right\":\n            addSecondXPenultY();\n            break;\n          default: {\n            addHorizontalCenterLine();\n            break;\n          }\n        }\n      } else {\n        // startPosition is left\n        switch (endPosition) {\n          case \"top\":\n          case \"right\":\n            addVerticalCenterLine();\n            break;\n          default: {\n            addPenultXSecondY();\n            break;\n          }\n        }\n      }\n      break;\n    }\n    case \"u\":\n      if (startPosition === \"right\") {\n        switch (endPosition) {\n          case \"right\": {\n            break;\n          }\n          case \"top\": {\n            addSecondXPenultY();\n            break;\n          }\n          default: {\n            addHorizontalCenterLine();\n            break;\n          }\n        }\n      } else if (startPosition === \"bottom\") {\n        switch (endPosition) {\n          case \"left\":\n          case \"right\":\n            addPenultXSecondY();\n            break;\n          default: {\n            addVerticalRightLine();\n            break;\n          }\n        }\n      } else if (startPosition === \"top\") {\n        switch (endPosition) {\n          case \"left\": {\n            addPenultXSecondY();\n            break;\n          }\n          case \"right\": {\n            addHorizontalCenterLine();\n            break;\n          }\n          case \"top\":\n            addVerticalRightLine();\n            break;\n          default: {\n            break;\n          }\n        }\n      } else {\n        // left\n        switch (endPosition) {\n          case \"left\":\n          case \"right\":\n            break;\n          default: {\n            points.push([second[0], penult[1]]);\n            break;\n          }\n        }\n      }\n      break;\n    case \"ru\":\n      if (startPosition === \"right\") {\n        switch (endPosition) {\n          case \"left\": {\n            addVerticalCenterLine();\n            break;\n          }\n          case \"top\": {\n            addSecondXPenultY();\n            break;\n          }\n          default: {\n            addPenultXSecondY();\n            break;\n          }\n        }\n      } else if (startPosition === \"bottom\") {\n        switch (endPosition) {\n          case \"top\": {\n            addVerticalCenterLine();\n            break;\n          }\n          default: {\n            addPenultXSecondY();\n            break;\n          }\n        }\n      } else if (startPosition === \"top\") {\n        switch (endPosition) {\n          case \"right\": {\n            addVerticalCenterLine();\n            break;\n          }\n          default: {\n            addSecondXPenultY();\n            break;\n          }\n        }\n      } else {\n        // left\n        switch (endPosition) {\n          case \"left\":\n          case \"top\":\n            addSecondXPenultY();\n            break;\n          default: {\n            addHorizontalCenterLine();\n            break;\n          }\n        }\n      }\n      break;\n    case \"l\":\n      if (startPosition === \"right\") {\n        switch (endPosition) {\n          case \"left\":\n          case \"right\":\n          case \"top\":\n            addHorizontalTopLine();\n            break;\n          default: {\n            addHorizontalBottomLine();\n            break;\n          }\n        }\n      } else if (startPosition === \"bottom\") {\n        switch (endPosition) {\n          case \"left\": {\n            addHorizontalBottomLine();\n            break;\n          }\n          case \"right\": {\n            addSecondXPenultY();\n            break;\n          }\n          case \"top\": {\n            addVerticalCenterLine();\n            break;\n          }\n          default: {\n            break;\n          }\n        }\n      } else if (startPosition === \"top\") {\n        switch (endPosition) {\n          case \"left\": {\n            addHorizontalTopLine();\n            break;\n          }\n          case \"right\": {\n            addSecondXPenultY();\n            break;\n          }\n          case \"top\": {\n            break;\n          }\n          default: {\n            addVerticalCenterLine();\n            break;\n          }\n        }\n      } else {\n        // left\n        switch (endPosition) {\n          case \"left\": {\n            addHorizontalTopLine();\n            break;\n          }\n          case \"right\": {\n            break;\n          }\n          default: {\n            addSecondXPenultY();\n            break;\n          }\n        }\n      }\n      break;\n    case \"r\":\n      if (startPosition === \"right\") {\n        switch (endPosition) {\n          case \"left\": {\n            break;\n          }\n          case \"right\": {\n            addHorizontalTopLine();\n            break;\n          }\n          default: {\n            addSecondXPenultY();\n            break;\n          }\n        }\n      } else if (startPosition === \"bottom\") {\n        switch (endPosition) {\n          case \"left\": {\n            addSecondXPenultY();\n            break;\n          }\n          case \"right\": {\n            addHorizontalBottomLine();\n            break;\n          }\n          case \"top\": {\n            addVerticalCenterLine();\n            break;\n          }\n          default: {\n            break;\n          }\n        }\n      } else if (startPosition === \"top\") {\n        switch (endPosition) {\n          case \"left\": {\n            addPenultXSecondY();\n            break;\n          }\n          case \"right\": {\n            addHorizontalTopLine();\n            break;\n          }\n          case \"top\": {\n            break;\n          }\n          default: {\n            addVerticalCenterLine();\n            break;\n          }\n        }\n      } else {\n        // left\n        switch (endPosition) {\n          case \"left\":\n          case \"right\":\n          case \"top\":\n            addHorizontalTopLine();\n            break;\n          default: {\n            addHorizontalBottomLine();\n            break;\n          }\n        }\n      }\n      break;\n    case \"ld\":\n      if (startPosition === \"right\") {\n        switch (endPosition) {\n          case \"left\": {\n            addHorizontalCenterLine();\n            break;\n          }\n          default: {\n            addSecondXPenultY();\n            break;\n          }\n        }\n      } else if (startPosition === \"bottom\") {\n        switch (endPosition) {\n          case \"left\": {\n            addPenultXSecondY();\n            break;\n          }\n          case \"top\": {\n            addHorizontalCenterLine();\n            break;\n          }\n          default: {\n            addSecondXPenultY();\n            break;\n          }\n        }\n      } else if (startPosition === \"top\") {\n        switch (endPosition) {\n          case \"left\":\n          case \"right\":\n          case \"top\":\n            addPenultXSecondY();\n            break;\n          default: {\n            addVerticalCenterLine();\n            break;\n          }\n        }\n      } else {\n        // left\n        switch (endPosition) {\n          case \"left\":\n          case \"top\":\n            addPenultXSecondY();\n            break;\n          case \"right\": {\n            addVerticalCenterLine();\n            break;\n          }\n          default: {\n            addSecondXPenultY();\n            break;\n          }\n        }\n      }\n      break;\n    case \"d\":\n      if (startPosition === \"right\") {\n        switch (endPosition) {\n          case \"left\": {\n            addHorizontalCenterLine();\n            break;\n          }\n          case \"right\": {\n            addPenultXSecondY();\n            break;\n          }\n          case \"top\": {\n            addSecondXPenultY();\n            break;\n          }\n          default: {\n            addVerticalRightLine();\n            break;\n          }\n        }\n      } else if (startPosition === \"bottom\") {\n        switch (endPosition) {\n          case \"left\":\n          case \"right\":\n            addPenultXSecondY();\n            break;\n          case \"top\": {\n            break;\n          }\n          default: {\n            addVerticalRightLine();\n            break;\n          }\n        }\n      } else if (startPosition === \"top\") {\n        switch (endPosition) {\n          case \"left\": {\n            addVerticalLeftLine();\n            break;\n          }\n          default: {\n            addVerticalRightLine();\n            break;\n          }\n        }\n      } else {\n        // left\n        switch (endPosition) {\n          case \"left\": {\n            break;\n          }\n          case \"right\": {\n            addHorizontalCenterLine();\n            break;\n          }\n          case \"top\": {\n            addSecondXPenultY();\n            break;\n          }\n          default: {\n            addVerticalLeftLine();\n            break;\n          }\n        }\n      }\n      break;\n    case \"rd\": {\n      if (startPosition === \"right\" && endPosition === \"left\") {\n        addVerticalCenterLine();\n      } else if (startPosition === \"right\" && endPosition === \"bottom\") {\n        addSecondXPenultY();\n      } else if (\n        (startPosition === \"right\" && endPosition === \"top\") ||\n        (startPosition === \"right\" && endPosition === \"right\")\n      ) {\n        addPenultXSecondY();\n      } else if (startPosition === \"bottom\" && endPosition === \"left\") {\n        addSecondXPenultY();\n      } else if (startPosition === \"bottom\" && endPosition === \"right\") {\n        addPenultXSecondY();\n      } else if (startPosition === \"bottom\" && endPosition === \"top\") {\n        addHorizontalCenterLine();\n      } else if (startPosition === \"bottom\" && endPosition === \"bottom\") {\n        addSecondXPenultY();\n      } else if (startPosition === \"top\" && endPosition === \"left\") {\n        addPenultXSecondY();\n      } else if (startPosition === \"top\" && endPosition === \"right\") {\n        addPenultXSecondY();\n      } else if (startPosition === \"top\" && endPosition === \"top\") {\n        addPenultXSecondY();\n      } else if (startPosition === \"top\" && endPosition === \"bottom\") {\n        addVerticalCenterLine();\n      } else if (startPosition === \"left\" && endPosition === \"left\") {\n        addSecondXPenultY();\n      } else if (startPosition === \"left\" && endPosition === \"right\") {\n        addHorizontalCenterLine();\n      } else if (startPosition === \"left\" && endPosition === \"top\") {\n        addHorizontalCenterLine();\n      } else if (startPosition === \"left\" && endPosition === \"bottom\") {\n        addSecondXPenultY();\n      }\n      break;\n    }\n  }\n  points.push(penult);\n  points.push(end);\n  return points;\n}\n\nfunction calcDirection(\n  p1: Point,\n  p2: Point\n): \"l\" | \"r\" | \"u\" | \"d\" | \"lu\" | \"ru\" | \"ld\" | \"rd\" {\n  // Use approximatelyEquals to fix the problem of css position precision\n  if (p2.x < p1.x && approximatelyEquals(p2.y, p1.y)) {\n    return \"l\";\n  }\n  if (p2.x > p1.x && approximatelyEquals(p2.y, p1.y)) {\n    return \"r\";\n  }\n  if (approximatelyEquals(p2.x, p1.x) && p2.y < p1.y) {\n    return \"u\";\n  }\n  if (approximatelyEquals(p2.x, p1.x) && p2.y > p1.y) {\n    return \"d\";\n  }\n  if (p2.x < p1.x && p2.y < p1.y) {\n    return \"lu\";\n  }\n  if (p2.x > p1.x && p2.y < p1.y) {\n    return \"ru\";\n  }\n  if (p2.x < p1.x && p2.y > p1.y) {\n    return \"ld\";\n  }\n  return \"rd\";\n}\n\nfunction distanceOfPoint2Point(p1: Point, p2: Point): number {\n  return Math.hypot(p1.x - p2.x, p1.y - p2.y);\n}\n\nfunction distanceOfPointToLine(point: Point, line: Line): number {\n  const start = line[0],\n    end = line[1];\n  const k = (end.y - start.y || 1) / (end.x - start.x || 1);\n  const b = start.y - k * start.x;\n  return Math.abs(k * point.x - point.y + b) / Math.sqrt(k * k + 1);\n}\n\nfunction between(num1: number, num2: number, num: number): boolean {\n  return (num > num1 && num < num2) || (num > num2 && num < num1);\n}\n\nfunction approximatelyEquals(n: number, m: number): boolean {\n  return Math.abs(m - n) <= 3;\n}\n\nfunction getEdgeOfPoints(points: Point[]): { start: Point; end: Point } {\n  const minX = points.reduce((prev, point) => {\n    return point.x < prev ? point.x : prev;\n  }, Infinity);\n  const maxX = points.reduce((prev, point) => {\n    return point.x > prev ? point.x : prev;\n  }, 0);\n  const minY = points.reduce((prev, point) => {\n    return point.y < prev ? point.y : prev;\n  }, Infinity);\n  const maxY = points.reduce((prev, point) => {\n    return point.y > prev ? point.y : prev;\n  }, 0);\n  return { start: { x: minX, y: minY }, end: { x: maxX, y: maxY } };\n}\n\nfunction isIntersected(\n  p: Point,\n  rect: {\n    start: Point;\n    end: Point;\n  }\n): boolean {\n  return (\n    p.x > rect.start.x &&\n    p.x < rect.end.x &&\n    p.y > rect.start.y &&\n    p.y < rect.end.y\n  );\n}\n\nfunction roundTo20(number: number): number {\n  return number < 20 ? 20 : number;\n}\nfunction locateConnector(\n  node: NodeData\n): { left: Point; right: Point; top: Point; bottom: Point } {\n  const halfWidth = 60;\n  const halfHeight = 30;\n  const top = { x: node.x + halfWidth, y: node.y };\n  const left = { x: node.x, y: node.y + halfHeight };\n  const bottom = { x: node.x + halfWidth, y: node.y + 60 };\n  const right = { x: node.x + 120, y: node.y + halfHeight };\n  return { left, right, top, bottom };\n}\n\n/**\n * Get angle positions: top-left, top-right, bottom-right, bottom-left\n * @param node\n */\nfunction locateAngle(node: NodeData): [Point, Point, Point, Point] {\n  return [\n    { x: node.x, y: node.y },\n    { x: node.x + 120, y: node.y },\n    { x: node.x + 120, y: node.y + 60 },\n    { x: node.x, y: node.y + 60 },\n  ];\n}\n\nconst lineGenerator: any = d3\n  .line()\n  .x((d) => d[0])\n  .y((d) => d[1]);\n\nfunction calcIntersectedConnections(\n  internalNodes: NodeData[],\n  internalConnections: ConnectionData[],\n  rect: { start: Point; end: Point }\n): ConnectionData[] {\n  const result: ConnectionData[] = [];\n  for (const internalConnection of internalConnections) {\n    const srcNodeData = internalNodes.find(\n      (item) => item.id === internalConnection.source.id\n    );\n    const destNodeData = internalNodes.find(\n      (item) => item.id === internalConnection.destination.id\n    );\n    const points = pathing(\n      locateConnector(srcNodeData!)[internalConnection.source.position],\n      locateConnector(destNodeData!)[internalConnection.destination.position],\n      internalConnection.source.position,\n      internalConnection.destination.position\n    );\n    if (\n      points.some((point) => isIntersected({ x: point[0], y: point[1] }, rect))\n    ) {\n      result.push(internalConnection);\n    }\n  }\n  return result;\n}\n\nfunction calcIntersectedNodes(\n  internalNodes: NodeData[],\n  edge: { start: Point; end: Point }\n): NodeData[] {\n  const tempCurrentNodes: NodeData[] = [];\n  internalNodes.forEach((item) => {\n    if (locateAngle(item).some((point) => isIntersected(point, edge))) {\n      tempCurrentNodes.push(item);\n    }\n  });\n  return tempCurrentNodes;\n}\n\nfunction createConnection(\n  sourceId: number,\n  sourcePosition: ConnectorPosition,\n  destinationId: number,\n  destinationPosition: ConnectorPosition\n): ConnectionData {\n  return {\n    source: { id: sourceId, position: sourcePosition },\n    destination: { id: destinationId, position: destinationPosition },\n    id: +new Date(),\n    type: \"pass\",\n  };\n}\n\nexport {\n  isIntersected,\n  distanceOfPointToLine,\n  distanceOfPoint2Point,\n  calcDirection,\n  getEdgeOfPoints,\n  between,\n  roundTo20,\n  pathing,\n  approximatelyEquals,\n  locateConnector,\n  locateAngle,\n  lineGenerator,\n  calcIntersectedConnections,\n  calcIntersectedNodes,\n  createConnection,\n};\n","import React from \"react\";\nimport { NodeProps } from \"./schema\";\n\nexport default function ({ data, isSelected = false }: NodeProps) {\n  const borderColor = isSelected ? \"#666666\" : \"#bbbbbb\";\n  const text =\n    !data.approvers || data.approvers.length === 0\n      ? \"No approver\"\n      : data.approvers.length > 1\n      ? `${data.approvers[0].name + \"...\"}`\n      : data.approvers[0].name;\n  return (\n    <React.Fragment>\n      <rect\n        x={data.x}\n        y={data.y}\n        height={20}\n        fill={\"#f1f3f4\"}\n        strokeWidth={1}\n        width={120}\n        stroke={borderColor}\n      />\n      <text x={data.x + 4} y={data.y + 15}>\n        {data.name}\n      </text>\n      <rect\n        width={120}\n        height={40}\n        fill={\"white\"}\n        x={data.x}\n        y={data.y + 20}\n        strokeWidth={1}\n        stroke={borderColor}\n      />\n      <text x={data.x + 60} y={data.y + 25 + 20} textAnchor={\"middle\"}>\n        {text}\n      </text>\n    </React.Fragment>\n  );\n}\n","import React from \"react\";\nimport { NodeProps } from \"./schema\";\n\nexport default function ({ data, isSelected = false }: NodeProps) {\n  const borderColor = isSelected ? \"#666666\" : \"#bbbbbb\";\n  const text = data.type === \"start\" ? \"Start\" : \"End\";\n  return (\n    <React.Fragment>\n      <ellipse\n        cx={data.x + 60}\n        cy={data.y + 30}\n        rx={60}\n        ry={30}\n        fill={\"white\"}\n        strokeWidth={1}\n        stroke={borderColor}\n      />\n      <text x={data.x + 60} y={data.y + 5 + 30} textAnchor={\"middle\"}>\n        {text}\n      </text>\n    </React.Fragment>\n  );\n}\n","import { ConnectorPosition, NodeData } from \"../schema\";\nimport OperationNode from \"./OperationNode\";\nimport StartEndNode from \"./StartEndNode\";\nimport React, { useMemo } from \"react\";\nimport { locateConnector } from \"../util\";\nimport styled from \"styled-components\";\n\nconst Circle = styled(\"circle\")<{ isConnecting: boolean }>`\n  stroke: #bbbbbb;\n  cursor: crosshair;\n  opacity: ${(props) => (props.isConnecting ? 1 : 0)};\n  fill: white;\n  stroke-width: 1px;\n\n  :hover {\n    opacity: 1;\n  }\n`;\nconst G = styled(\"g\")`\n  :hover {\n    circle {\n      opacity: 1;\n    }\n  }\n`;\n\ninterface NodeProps {\n  data: NodeData;\n  isSelected: boolean;\n  isConnecting: boolean;\n  onDoubleClick: (event: React.MouseEvent<SVGGElement, MouseEvent>) => void;\n  onMouseDown: (event: React.MouseEvent<SVGGElement, MouseEvent>) => void;\n  onConnectorMouseDown: (position: ConnectorPosition) => void;\n}\n\nexport default function ({\n  data,\n  isSelected,\n  isConnecting,\n  onDoubleClick,\n  onMouseDown,\n  onConnectorMouseDown,\n}: NodeProps) {\n  const position = useMemo(() => locateConnector(data), [data]);\n  return (\n    <React.Fragment>\n      <G onDoubleClick={onDoubleClick} onMouseDown={onMouseDown}>\n        {data.type !== \"start\" && data.type !== \"end\" ? (\n          <OperationNode data={data} isSelected={isSelected} />\n        ) : (\n          <StartEndNode data={data} isSelected={isSelected} />\n        )}\n        {Object.keys(position).map((key) => {\n          return (\n            <Circle\n              key={key}\n              isConnecting={isConnecting}\n              cx={position[key as ConnectorPosition].x}\n              cy={position[key as ConnectorPosition].y}\n              r={4}\n              onMouseDown={(event) => {\n                event.stopPropagation();\n                onConnectorMouseDown(key as ConnectorPosition);\n              }}\n            />\n          );\n        })}\n      </G>\n    </React.Fragment>\n  );\n}\n","const defaultConnectionColors = {\n  pass: \"#52c41a\",\n  reject: \"red\",\n};\n\nconst selectedConnectionColors = {\n  pass: \"#12640a\",\n  reject: \"darkred\",\n};\nexport { defaultConnectionColors, selectedConnectionColors };\n","import {lineGenerator, locateConnector, pathing} from \"../util\";\nimport React, {useCallback, useMemo} from \"react\";\nimport {ConnectionData, ConnectorPosition, NodeData} from \"../schema\";\nimport {defaultConnectionColors, selectedConnectionColors} from \"./constant\";\n\ninterface ConnectionProps {\n  data: ConnectionData;\n  nodes: NodeData[];\n  isSelected: boolean;\n  onMouseDown: (event: React.MouseEvent<SVGPathElement, MouseEvent>) => void;\n  onDoubleClick?: (event: React.MouseEvent<SVGGElement, MouseEvent>) => void;\n}\n\nexport default function ({\n  data,\n  nodes,\n  isSelected,\n  onMouseDown,\n  onDoubleClick,\n}: ConnectionProps) {\n  const getNodeConnectorOffset = useCallback(\n    (nodeId: number, connectorPosition: ConnectorPosition) => {\n      const node = nodes.filter((item) => item.id === nodeId)[0];\n      return locateConnector(node)[connectorPosition];\n    },\n    [nodes]\n  );\n  const points = pathing(\n    getNodeConnectorOffset(data.source.id, data.source.position),\n    getNodeConnectorOffset(data.destination.id, data.destination.position),\n    data.source.position,\n    data.destination.position\n  );\n  const colors = useMemo((): { pass: string; reject: string } => {\n    return isSelected ? selectedConnectionColors : defaultConnectionColors;\n  }, [isSelected]);\n  return (\n    <g>\n      {points.map((_point, i) => {\n        if (i > points.length - 2) {\n          return <React.Fragment/>;\n        }\n\n        const source = points[i];\n        const destination = points[i + 1];\n        const isLast = i === points.length - 2;\n        const color = colors[data.type];\n        const id = `arrow${color.replace(\"#\", \"\")}`;\n        return (\n          <React.Fragment key={i}>\n            <path\n              stroke={colors[data.type]}\n              strokeWidth={1}\n              fill={\"none\"}\n              d={lineGenerator([source, destination])}\n              markerEnd={isLast ? `url(#${id})` : undefined}\n            />\n            {isLast && (\n              <marker\n                id={id}\n                markerUnits={\"strokeWidth\"}\n                viewBox={\"0 0 12 12\"}\n                refX={9}\n                refY={6}\n                markerWidth={12}\n                markerHeight={12}\n                orient={\"auto\"}\n              >\n                <path d={\"M2,2 L10,6 L2,10 L6,6 L2,2\"} fill={color} />\n              </marker>\n            )}\n            <path\n              onMouseDown={onMouseDown}\n              onDoubleClick={(event) => {\n                event.stopPropagation();\n                onDoubleClick?.(event);\n              }}\n              stroke={\"transparent\"}\n              strokeWidth={5}\n              fill={\"none\"}\n              d={lineGenerator([source, destination])}\n            />\n          </React.Fragment>\n        );\n      })}\n    </g>\n  );\n}\n","import React, {\n  CSSProperties,\n  forwardRef,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useState,\n} from \"react\";\nimport styled from \"styled-components\";\nimport update from \"immutability-helper\";\nimport {\n  ConnectionData,\n  ConnectorPosition,\n  Line,\n  NodeData,\n  Point,\n  SelectionInfo,\n} from \"./schema\";\nimport {\n  calcDirection,\n  calcIntersectedConnections,\n  calcIntersectedNodes,\n  createConnection,\n  distanceOfPoint2Point,\n  distanceOfPointToLine,\n  getEdgeOfPoints,\n  lineGenerator,\n  locateAngle,\n  locateConnector,\n  pathing,\n} from \"./util\";\nimport Node from \"./Node/Node\";\nimport Connection from \"./Connection/Connection\";\nimport { defaultConnectionColors } from \"./Connection/constant\";\n\nconst SVG = styled(\"svg\")`\n  background-size: 20px 20px, 20px 20px, 10px 10px, 10px 10px;\n  background-image: linear-gradient(to right, #dfdfdf 1px, transparent 1px),\n    linear-gradient(to bottom, #dfdfdf 1px, transparent 1px),\n    linear-gradient(to right, #f1f1f1 1px, transparent 1px),\n    linear-gradient(to bottom, #f1f1f1 1px, transparent 1px);\n  background-position: left -1px top -1px, left -1px top -1px,\n    left -1px top -1px, left -1px top -1px;\n  height: 100%;\n  width: 100%;\n  border: 1px solid #dfdfdf;\n\n  text {\n    moz-user-select: -moz-none;\n    -moz-user-select: none;\n    -o-user-select: none;\n    -khtml-user-select: none;\n    -webkit-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n  }\n`;\n\ninterface FlowchartProps {\n  style?: CSSProperties;\n  defaultNodes: NodeData[];\n  defaultConnections: ConnectionData[];\n  onEditNode?: (\n    data: NodeData,\n    setNodes: React.Dispatch<React.SetStateAction<NodeData[]>>\n  ) => void;\n  onCreateNode?: (\n    data: NodeData,\n    setNodes: React.Dispatch<React.SetStateAction<NodeData[]>>\n  ) => void;\n  onEditConnection?: (\n    data: ConnectionData,\n    setConnections: React.Dispatch<React.SetStateAction<ConnectionData[]>>\n  ) => void;\n  onCreateConnection?: (\n    data: ConnectionData,\n    setConnections: React.Dispatch<React.SetStateAction<ConnectionData[]>>\n  ) => void;\n  readonly?: boolean;\n}\n\nexport default forwardRef(\n  (\n    {\n      defaultNodes,\n      defaultConnections,\n      readonly = false,\n      onEditNode,\n      onCreateNode,\n      onEditConnection,\n      onCreateConnection,\n      style,\n    }: FlowchartProps,\n    ref: any\n  ) => {\n    const [internalNodes, setInternalNodes] = useState<NodeData[]>(\n      defaultNodes\n    );\n    const [internalConnections, setInternalConnections] = useState<\n      ConnectionData[]\n    >(defaultConnections);\n    useEffect(() => {\n      setInternalConnections(defaultConnections);\n      setInternalNodes(defaultNodes);\n    }, [defaultConnections, defaultNodes]);\n    const [currentNodes, setCurrentNodes] = useState<number[]>([]);\n    const [currentConnections, setCurrentConnections] = useState<\n      ConnectionData[]\n    >([]);\n    const [selectionInfo, setSelectionInfo] = useState<SelectionInfo>();\n    const [connectingInfo, setConnectingInfo] = useState<{\n      source: NodeData;\n      sourcePosition: ConnectorPosition;\n    }>();\n    const [draggingInfo, setDraggingInfo] = useState<{\n      // todo: rename\n      target: number[];\n      delta: {\n        x: number;\n        y: number;\n      }[];\n    }>();\n    const [cursorToChartOffset, setCursorToChartOffset] = useState<Point>({\n      x: 0,\n      y: 0,\n    });\n    const handleSVGDoubleClick = useCallback(\n      (event) => {\n        const point = {\n          x: event.nativeEvent.offsetX,\n          y: event.nativeEvent.offsetY,\n          id: +new Date(),\n        };\n        let nodeData: NodeData;\n        if (!internalNodes.find((item) => item.type === \"start\")) {\n          nodeData = {\n            type: \"start\",\n            name: \"Start\",\n            ...point,\n          };\n        } else if (!internalNodes.find((item) => item.type === \"end\")) {\n          nodeData = {\n            type: \"end\",\n            name: \"End\",\n            ...point,\n          };\n        } else {\n          nodeData = {\n            ...point,\n            name: \"New\",\n            type: \"operation\",\n          };\n        }\n        return onCreateNode?.(nodeData, setInternalNodes);\n      },\n      [internalNodes, onCreateNode]\n    );\n    const handleSVGMouseDown = useCallback((event) => {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n      // @ts-ignore: can not access tagName in event.target\n      if (event.ctrlKey || event.metaKey || event.target.tagName !== \"svg\") {\n        // ignore propagation\n        return;\n      }\n\n      const point = {\n        x: event.nativeEvent.offsetX,\n        y: event.nativeEvent.offsetY,\n      };\n      setSelectionInfo({\n        start: point,\n        end: point,\n      });\n      setCurrentNodes([]);\n      setCurrentConnections([]);\n    }, []);\n    const handleSVGMouseMove = useCallback(\n      (event) => {\n        const currentCursorToChartOffset: Point = {\n          x: event.nativeEvent.offsetX,\n          y: event.nativeEvent.offsetY,\n        };\n\n        setCursorToChartOffset(currentCursorToChartOffset);\n\n        if (selectionInfo) {\n          setSelectionInfo({\n            start: selectionInfo.start,\n            end: currentCursorToChartOffset,\n          });\n\n          const edge = getEdgeOfPoints([\n            selectionInfo.start,\n            currentCursorToChartOffset,\n          ]);\n          setCurrentNodes(\n            calcIntersectedNodes(internalNodes, edge).map((item) => item.id)\n          );\n          setCurrentConnections(\n            calcIntersectedConnections(internalNodes, internalConnections, edge)\n          );\n        } else if (draggingInfo) {\n          setInternalNodes((prevState) => {\n            let result: NodeData[] = prevState;\n            for (let i = 0; i < draggingInfo.target.length; i++) {\n              const t = draggingInfo.target[i];\n              const findIndex = result.findIndex((item) => item.id === t);\n              const delta = draggingInfo.delta[i];\n              result = update(result, {\n                [findIndex]: {\n                  x: {\n                    $set: currentCursorToChartOffset.x - delta.x,\n                  },\n                  y: {\n                    $set: currentCursorToChartOffset.y - delta.y,\n                  },\n                },\n              });\n            }\n            return result;\n          });\n        }\n      },\n      [draggingInfo, internalConnections, internalNodes, selectionInfo]\n    );\n    const moveCurrentNodes = useCallback(\n      (x, y) => {\n        const indexes = currentNodes.map((currentNode) =>\n          internalNodes.findIndex(\n            (internalNode) => internalNode.id === currentNode\n          )\n        );\n        setInternalNodes((prevState) => {\n          let tempState = prevState;\n          for (const index of indexes) {\n            tempState = update(tempState, {\n              [index]: {\n                x: {\n                  $apply: (prev) => prev + x,\n                },\n                y: {\n                  $apply: (prev) => prev + y,\n                },\n              },\n            });\n          }\n          return tempState;\n        });\n      },\n      [currentNodes, internalNodes]\n    );\n    const remove = useCallback(() => {\n      if (readonly) return;\n\n      // Delete connections\n      setInternalConnections((prevState) => {\n        // Splice arguments of selected connections\n        const list1: [\n          number,\n          number\n        ][] = currentConnections.map((currentConn) => [\n          prevState.findIndex((interConn) => interConn.id === currentConn.id),\n          1,\n        ]);\n        // Splice arguments of connections of selected nodes\n        const list2: [number, number][] = currentNodes\n          .map((currNode) =>\n            internalConnections.filter(\n              (interConn) =>\n                interConn.source.id === currNode ||\n                interConn.destination.id === currNode\n            )\n          )\n          .flat()\n          .map((currentConn) => [\n            prevState.findIndex((interConn) => interConn.id === currentConn.id),\n            1,\n          ]);\n        return update(prevState, {\n          $splice: [...list1, ...list2].sort((a, b) => b[0] - a[0]),\n        });\n      });\n\n      // Delete nodes\n      setInternalNodes((prevState) =>\n        update(prevState, {\n          $splice: currentNodes\n            .map((currNode) => [\n              prevState.findIndex((interNode) => interNode.id === currNode),\n              1,\n            ])\n            .sort((a, b) => b[0] - a[0]) as [number, number][],\n        })\n      );\n    }, [currentConnections, currentNodes, internalConnections, readonly]);\n    const handleSVGKeyDown = useCallback(\n      (event) => {\n        switch (event.keyCode) {\n          case 37:\n            moveCurrentNodes(-10, 0);\n            break;\n          case 38:\n            moveCurrentNodes(0, -10);\n            break;\n          case 39:\n            moveCurrentNodes(10, 0);\n            break;\n          case 40:\n            moveCurrentNodes(0, 10);\n            break;\n          case 27:\n            setCurrentNodes([]);\n            setCurrentConnections([]);\n            break;\n          case 65:\n            if (\n              (event.ctrlKey || event.metaKey) &&\n              document.activeElement === document.getElementById(\"chart\")\n            ) {\n              setCurrentNodes([]);\n              setCurrentConnections([]);\n              setCurrentNodes(internalNodes.map((item) => item.id));\n              setCurrentConnections([...currentConnections]);\n            }\n            break;\n          case 46:\n          case 8:\n            remove();\n            break;\n          default:\n            break;\n        }\n      },\n      [currentConnections, internalNodes, moveCurrentNodes, remove]\n    );\n    const handleSVGMouseUp = useCallback(() => {\n      setSelectionInfo(undefined);\n      setConnectingInfo(undefined);\n      setDraggingInfo(undefined);\n\n      // Align dragging node\n      if (draggingInfo) {\n        setInternalNodes((prevState) => {\n          let result: NodeData[] = prevState;\n          for (const t of draggingInfo.target) {\n            result = update(result, {\n              [result.findIndex((item) => item.id === t)]: {\n                x: {\n                  $apply: (prevState) =>\n                    Math.round(Math.round(prevState) / 10) * 10,\n                },\n                y: {\n                  $apply: (prevState) =>\n                    Math.round(Math.round(prevState) / 10) * 10,\n                },\n              },\n            });\n          }\n          return result!;\n        });\n      }\n\n      // Connect nodes\n      if (!connectingInfo) {\n        return;\n      }\n      let node: NodeData | null = null;\n      let position: ConnectorPosition | null = null;\n      for (const internalNode of internalNodes) {\n        const locations = locateConnector(internalNode);\n        for (const prop in locations) {\n          const entry = locations[prop as ConnectorPosition];\n          if (distanceOfPoint2Point(entry, cursorToChartOffset) < 6) {\n            node = internalNode;\n            position = prop as ConnectorPosition;\n          }\n        }\n      }\n      if (!node || !position) {\n        return;\n      }\n      if (connectingInfo.source.id === node.id) {\n        // Node can not connect to itself\n        return;\n      }\n      const newConnection = createConnection(\n        connectingInfo.source.id,\n        connectingInfo.sourcePosition,\n        node.id,\n        position\n      );\n      onCreateConnection?.(newConnection, setInternalConnections);\n    }, [\n      connectingInfo,\n      cursorToChartOffset,\n      draggingInfo,\n      internalNodes,\n      onCreateConnection,\n    ]);\n\n    // todo: cache compute result\n    let points: [number, number][] | undefined = undefined;\n    if (connectingInfo) {\n      let endPosition: ConnectorPosition | null = null;\n      for (const internalNode of internalNodes) {\n        const locations = locateConnector(internalNode);\n        for (const prop in locations) {\n          const entry = locations[prop as ConnectorPosition];\n          if (distanceOfPoint2Point(entry, cursorToChartOffset) < 6) {\n            endPosition = prop as ConnectorPosition;\n          }\n        }\n      }\n\n      points = pathing(\n        locateConnector(connectingInfo.source)[connectingInfo.sourcePosition],\n        cursorToChartOffset!,\n        connectingInfo.sourcePosition,\n        endPosition\n      );\n    }\n    const guidelines: Line[] = [];\n    if (draggingInfo) {\n      for (const source of draggingInfo.target) {\n        const sourceAnglePoints = locateAngle(\n          internalNodes.find((item) => item.id === source)!\n        );\n        for (let i = 0; i < sourceAnglePoints.length; i++) {\n          const sourceAnglePoint = {\n            x: Math.round(Math.round(sourceAnglePoints[i].x) / 10) * 10,\n            y: Math.round(Math.round(sourceAnglePoints[i].y) / 10) * 10,\n          };\n\n          let lines: Line[];\n          let directions: (\"l\" | \"r\" | \"u\" | \"d\" | \"lu\" | \"ru\" | \"ld\" | \"rd\")[];\n          switch (i) {\n            case 0: {\n              lines = [\n                [{ x: sourceAnglePoint.x, y: 0 }, sourceAnglePoint],\n                [{ x: 0, y: sourceAnglePoint.y }, sourceAnglePoint],\n              ];\n              directions = [\"lu\", \"u\", \"l\"];\n              break;\n            }\n            case 1: {\n              lines = [\n                [{ x: sourceAnglePoint.x, y: 0 }, sourceAnglePoint],\n                // todo: replace 10000 with the width of svg\n                [{ x: 10000, y: sourceAnglePoint.y }, sourceAnglePoint],\n              ];\n              directions = [\"ru\", \"u\", \"r\"];\n              break;\n            }\n            case 2: {\n              lines = [\n                [{ x: sourceAnglePoint.x, y: 10000 }, sourceAnglePoint],\n                [{ x: 10000, y: sourceAnglePoint.y }, sourceAnglePoint],\n              ];\n              directions = [\"r\", \"rd\", \"d\"];\n              break;\n            }\n            default: {\n              lines = [\n                [{ x: sourceAnglePoint.x, y: 10000 }, sourceAnglePoint],\n                [{ x: 0, y: sourceAnglePoint.y }, sourceAnglePoint],\n              ];\n              directions = [\"l\", \"ld\", \"d\"];\n              break;\n            }\n          }\n\n          for (const destination of internalNodes.filter(\n            (internalNode) => internalNode.id !== source\n          )) {\n            let line: Line | null = null;\n            for (const destinationPoint of locateAngle(destination)) {\n              const direction = calcDirection(\n                sourceAnglePoint,\n                destinationPoint\n              );\n              if (\n                directions.indexOf(direction) > -1 &&\n                (distanceOfPointToLine(destinationPoint, lines[0]) < 5 ||\n                  distanceOfPointToLine(destinationPoint, lines[1]) < 5)\n              ) {\n                if (\n                  line === null ||\n                  distanceOfPoint2Point(destinationPoint, sourceAnglePoint) <\n                    distanceOfPoint2Point(line[0], line[1])\n                ) {\n                  line = [destinationPoint, sourceAnglePoint];\n                }\n              }\n            }\n            if (line) {\n              guidelines.push(line);\n            }\n          }\n        }\n      }\n    }\n\n    useImperativeHandle(ref, () => ({\n      getData() {\n        return {\n          nodes: internalNodes,\n          connections: internalConnections,\n        };\n      },\n    }));\n\n    return (\n      <React.Fragment>\n        <SVG\n          id={\"chart\"}\n          tabIndex={0}\n          onKeyDown={handleSVGKeyDown}\n          style={style}\n          onDoubleClick={handleSVGDoubleClick}\n          onMouseUp={handleSVGMouseUp}\n          onMouseDown={handleSVGMouseDown}\n          onMouseMove={handleSVGMouseMove}\n        >\n          {internalNodes?.map((node) => (\n            <Node\n              key={node.id}\n              isSelected={currentNodes.some((item) => item === node.id)}\n              isConnecting={connectingInfo !== undefined}\n              data={node}\n              onDoubleClick={(event) => {\n                event.stopPropagation();\n                onEditNode?.(node, setInternalNodes);\n              }}\n              onMouseDown={(event) => {\n                if (event.ctrlKey || event.metaKey) {\n                  const findIndex = currentNodes.findIndex(\n                    (item) => item === node.id\n                  );\n                  if (findIndex === -1) {\n                    setCurrentNodes([...currentNodes, node.id]);\n                  } else {\n                    setCurrentNodes(\n                      update(currentNodes, {\n                        $splice: [[findIndex, 1]],\n                      })\n                    );\n                  }\n                } else {\n                  let tempCurrentNodes: number[] = currentNodes;\n                  if (\n                    !currentNodes.some((currentNode) => currentNode === node.id)\n                  ) {\n                    tempCurrentNodes = [node.id];\n                    setCurrentNodes(tempCurrentNodes);\n                  }\n                  setCurrentConnections([]);\n                  setDraggingInfo({\n                    target: tempCurrentNodes,\n                    delta: tempCurrentNodes.map((tempCurrentNode) => {\n                      const find = internalNodes.find(\n                        (item) => item.id === tempCurrentNode\n                      )!;\n                      return {\n                        x: cursorToChartOffset.x - find.x,\n                        y: cursorToChartOffset.y - find.y,\n                      };\n                    }),\n                  });\n                }\n              }}\n              onConnectorMouseDown={(position) => {\n                if (node.type === \"end\") {\n                  return;\n                }\n\n                setConnectingInfo({\n                  source: node,\n                  sourcePosition: position,\n                });\n              }}\n            />\n          ))}\n          {internalConnections?.map((conn) => {\n            return (\n              <Connection\n                key={conn.id}\n                isSelected={currentConnections.some(\n                  (item) => conn.id === item.id\n                )}\n                onDoubleClick={() =>\n                  onEditConnection?.(conn, setInternalConnections)\n                }\n                onMouseDown={(event) => {\n                  if (event.ctrlKey || event.metaKey) {\n                    const findIndex = currentConnections.findIndex(\n                      (item) => item.id === conn.id\n                    );\n                    if (findIndex === -1) {\n                      setCurrentConnections([...currentConnections, conn]);\n                    } else {\n                      setCurrentConnections(\n                        update(currentConnections, {\n                          $splice: [[findIndex, 1]],\n                        })\n                      );\n                    }\n                  } else {\n                    setCurrentNodes([]);\n                    setCurrentConnections([conn]);\n                  }\n                }}\n                data={conn}\n                nodes={internalNodes}\n              />\n            );\n          })}\n          {selectionInfo && (\n            <rect\n              stroke={\"lightblue\"}\n              fill={\"lightblue\"}\n              fillOpacity={0.8}\n              x={\n                getEdgeOfPoints([selectionInfo.start, selectionInfo.end]).start\n                  .x\n              }\n              y={\n                getEdgeOfPoints([selectionInfo.start, selectionInfo.end]).start\n                  .y\n              }\n              width={\n                getEdgeOfPoints([selectionInfo.start, selectionInfo.end]).end\n                  .x -\n                getEdgeOfPoints([selectionInfo.start, selectionInfo.end]).start\n                  .x\n              }\n              height={\n                getEdgeOfPoints([selectionInfo.start, selectionInfo.end]).end\n                  .y -\n                getEdgeOfPoints([selectionInfo.start, selectionInfo.end]).start\n                  .y\n              }\n            />\n          )}\n          {connectingInfo && (\n            <g>\n              {points!.map((_point, i) => {\n                if (i > points!.length - 2) {\n                  return <React.Fragment/>;\n                }\n\n                const source = points![i];\n                const destination = points![i + 1];\n                const isLast = i === points!.length - 2;\n                const color = defaultConnectionColors.pass;\n                const id = `arrow${color.replace(\"#\", \"\")}`;\n                return (\n                  <React.Fragment>\n                    <path\n                      stroke={defaultConnectionColors.pass}\n                      strokeWidth={1}\n                      fill={\"none\"}\n                      d={lineGenerator([source, destination])}\n                      markerEnd={isLast ? `url(#${id})` : undefined}\n                    />\n                    {isLast && (\n                      <marker\n                        id={id}\n                        markerUnits={\"strokeWidth\"}\n                        viewBox={\"0 0 12 12\"}\n                        refX={9}\n                        refY={6}\n                        markerWidth={12}\n                        markerHeight={12}\n                        orient={\"auto\"}\n                      >\n                        <path d={\"M2,2 L10,6 L2,10 L6,6 L2,2\"} fill={color} />\n                      </marker>\n                    )}\n                    <path\n                      stroke={\"transparent\"}\n                      strokeWidth={5}\n                      fill={\"none\"}\n                      d={lineGenerator([source, destination])}\n                    />\n                  </React.Fragment>\n                );\n              })}\n            </g>\n          )}\n          {guidelines.map((guideline, index) => (\n            <g key={index}>\n              <line\n                strokeDasharray={\"3 3\"}\n                stroke={\"#666666\"}\n                strokeWidth={1}\n                fill={\"none\"}\n                x1={guideline[0].x}\n                y1={guideline[0].y}\n                x2={guideline[1].x}\n                y2={guideline[1].y}\n              />\n            </g>\n          ))}\n        </SVG>\n      </React.Fragment>\n    );\n  }\n);\n","import React, { useRef, useState } from 'react'\n\nimport Flowchart from 'flowchart-react'\nimport 'flowchart-react/dist/index.css'\nimport { ConnectionData, NodeData, NodeType } from '../../src/Flowchart/schema'\nimport { Form, Input, Modal, Select } from 'antd'\nimport update from 'immutability-helper'\nimport \"antd/dist/antd.css\";\n\nconst App = () => {\n  const [nodes] = useState<NodeData[]>([\n    {\n      type: 'start',\n      name: 'Start',\n      x: 150,\n      y: 190,\n      id: 1604410569920,\n      approvers: []\n    },\n    {\n      type: 'end',\n      name: 'End',\n      x: 500,\n      y: 190,\n      id: 1604410572363,\n      approvers: []\n    },\n    {\n      x: 330,\n      y: 190,\n      id: 1604410575428,\n      name: 'New',\n      type: 'operation',\n      approvers: [{ name: 'Joyce', id: '1' }]\n    },\n    {\n      x: 330,\n      y: 300,\n      id: 1604410591865,\n      name: 'New',\n      type: 'operation',\n      approvers: []\n    }\n  ])\n  const [connections] = useState<ConnectionData[]>([\n    {\n      source: { id: 1604410569920, position: 'right' },\n      destination: { id: 1604410575428, position: 'left' },\n      id: 1604410587907,\n      type: 'pass'\n    },\n    {\n      source: { id: 1604410575428, position: 'right' },\n      destination: { id: 1604410572363, position: 'left' },\n      id: 1604410590524,\n      type: 'pass'\n    },\n    {\n      source: { id: 1604410569920, position: 'bottom' },\n      destination: { id: 1604410591865, position: 'left' },\n      id: 1604410596866,\n      type: 'pass'\n    },\n    {\n      source: { id: 1604410591865, position: 'right' },\n      destination: { id: 1604410572363, position: 'bottom' },\n      id: 1604410599205,\n      type: 'pass'\n    }\n  ])\n  const setInternalNodes = useRef<React.Dispatch<React.SetStateAction<NodeData[]>>>()\n  const setInternalConnections = useRef<React.Dispatch<React.SetStateAction<ConnectionData[]>>>()\n  const flowchartRef = useRef<any>()\n  const [connectionForm, setConnectionForm] = useState<{\n    visible: boolean;\n    type: 'pass' | 'reject';\n    id?: number;\n  }>({ visible: false, type: 'pass' })\n  const [nodeForm, setNodeForm] = useState<{\n    visible: boolean;\n    id?: number;\n    name: string;\n    type: NodeType;\n    approvers?: { name: string; [key: string]: any }[];\n  }>({\n    visible: false,\n    name: '',\n    type: 'operation'\n  })\n\n  return <div className=\"container\" style={{ height: 500 }}>\n    <h1 className=\"title\">Flowchart React</h1>\n    <h5 className=\"subtitle\">\n      Flowchart & Flowchart designer component for React.js.\n    </h5>\n    <div id=\"toolbar\">\n      <button disabled={true} onClick={() => {\n      }}>\n        Add(Double-click canvas)\n      </button>\n      <button disabled={true}>Delete(Del)</button>\n      <button disabled={true}>Edit(Double-click node)</button>\n      <button\n        onClick={() =>\n          alert(JSON.stringify(flowchartRef.current.getData()))\n        }\n      >\n        Save\n      </button>\n    </div>\n    <>\n      <Flowchart\n        ref={flowchartRef}\n        onEditConnection={(data, setConnections) => {\n          setInternalConnections.current = setConnections\n          setConnectionForm({\n            visible: true,\n            id: data.id,\n            type: data.type\n          })\n        }}\n        onCreateConnection={(data, setConnections) => {\n          setInternalConnections.current = setConnections\n          setConnections((prevState) => [...prevState, data])\n        }}\n        onEditNode={(data, setNodes) => {\n          setInternalNodes.current = setNodes\n          setNodeForm({\n            approvers: data.approvers,\n            name: data.name,\n            type: data.type,\n            visible: true,\n            id: data.id\n          })\n        }}\n        onCreateNode={(data, setNodes) => {\n          setInternalNodes.current = setNodes\n          setNodes((prevState) => [\n            ...prevState,\n            { ...data, approvers: [] }\n          ])\n        }}\n        defaultNodes={nodes}\n        defaultConnections={connections}\n      />\n      <Modal\n        visible={nodeForm.visible}\n        title={'节点'}\n        width={400}\n        onCancel={() =>\n          setNodeForm({\n            id: undefined,\n            type: 'operation',\n            visible: false,\n            name: '',\n            approvers: undefined\n          })\n        }\n        onOk={() => {\n          setNodeForm({\n            id: undefined,\n            type: 'operation',\n            visible: false,\n            name: '',\n            approvers: undefined\n          })\n          setInternalNodes.current!((prevState) =>\n            update(prevState, {\n              [prevState.findIndex((item) => item.id === nodeForm.id)]: {\n                name: {\n                  $set: nodeForm.name\n                },\n                type: {\n                  $set: nodeForm.type\n                },\n                approvers: {\n                  $set: nodeForm.approvers\n                }\n              }\n            })\n          )\n        }}\n      >\n        <Form\n          labelAlign={'right'}\n          labelCol={{\n            span: 4\n          }}\n        >\n          <Form.Item label={'名称'}>\n            <Input\n              value={nodeForm.name}\n              onChange={(event) =>\n                setNodeForm((prevState) => ({\n                  ...prevState,\n                  name: event.target.value\n                }))\n              }\n            />\n          </Form.Item>\n          <Form.Item label={'类型'}>\n            <Select\n              value={nodeForm.type}\n              onChange={(event) => {\n                setNodeForm((prevState) => ({\n                  ...prevState,\n                  type: event as NodeType\n                }))\n              }}\n            >\n              <Select.Option value={'start'}>开始</Select.Option>\n              <Select.Option value={'end'}>结束</Select.Option>\n              <Select.Option value={'operation'}>审核</Select.Option>\n            </Select>\n          </Form.Item>\n          <Form.Item label={'审核人'}>\n            <Select\n              value={nodeForm.approvers && nodeForm.approvers.length > 0 ? nodeForm.approvers[0].name : undefined}\n              onChange={(_event, option: any) => {\n                setNodeForm((prevState) => ({\n                  ...prevState,\n                  approvers: [{ name: option.children, id: option.value }]\n                }))\n              }}\n            >\n              <Select.Option value={'1'}>Joyce</Select.Option>\n              <Select.Option value={'2'}>Tiramisu</Select.Option>\n            </Select>\n          </Form.Item>\n        </Form>\n      </Modal>\n      <Modal\n        visible={connectionForm.visible}\n        title={'流转'}\n        width={400}\n        onCancel={() =>\n          setConnectionForm({\n            id: undefined,\n            type: 'pass',\n            visible: false\n          })\n        }\n        onOk={() => {\n          setConnectionForm({\n            id: undefined,\n            type: 'pass',\n            visible: false\n          })\n          setInternalConnections.current!((prevState) =>\n            update(prevState, {\n              [prevState.findIndex(\n                (item) => item.id === connectionForm.id\n              )]: {\n                type: {\n                  $set: connectionForm.type\n                }\n              }\n            })\n          )\n        }}\n      >\n        <Form>\n          <Form.Item label={'类型'}>\n            <Select\n              value={connectionForm.type}\n              onChange={(event) => {\n                setConnectionForm((prevState) => ({\n                  ...prevState,\n                  type: event as 'pass' | 'reject'\n                }))\n              }}\n            >\n              <Select.Option value={'pass'}>同意</Select.Option>\n              <Select.Option value={'reject'}>驳回</Select.Option>\n            </Select>\n          </Form.Item>\n        </Form>\n      </Modal>\n    </>\n  </div>\n\n}\n\nexport default App;\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}